From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ChA0S-f4me <Nikita.da.ok@gmail.com>
Date: Thu, 16 Jun 2022 20:47:46 +0300
Subject: [PATCH] Matter Secure Seed Feature


diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java
index 2998a4dda1d756161102acca381bb6ba8ec242e2..427b76a0344cf247820807d2cb1a4a2fc6cf1ae4 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServerProperties.java
@@ -122,7 +122,7 @@ public class DedicatedServerProperties extends Settings<DedicatedServerPropertie
         this.textFilteringConfig = this.get("text-filtering-config", "");
         this.playerIdleTimeout = this.getMutable("player-idle-timeout", 0);
         this.whiteList = this.getMutable("white-list", false);
-        this.worldGenProperties = new DedicatedServerProperties.WorldGenProperties(this.get("level-seed", ""), (JsonObject) this.get("generator-settings", (s) -> {
+        this.worldGenProperties = new DedicatedServerProperties.WorldGenProperties(this.get("level-seed", ""), this.get("feature-level-seed", ""), (JsonObject) this.get("generator-settings", (s) -> {
             return GsonHelper.parse(!s.isEmpty() ? s : "{}");
         }, new JsonObject()), this.get("generate-structures", true), (String) this.get("level-type", (s) -> {
             return s.toLowerCase(Locale.ROOT);
@@ -155,8 +155,8 @@ public class DedicatedServerProperties extends Settings<DedicatedServerPropertie
         return this.worldGenSettings;
     }
 
-    // CraftBukkit start - decompile error
-    public static record WorldGenProperties(String levelSeed, JsonObject generatorSettings, boolean generateStructures, String levelType) {
+    // CraftBukkit start - decompile error // Matter
+    public static record WorldGenProperties(String levelSeed, String featureSeed, JsonObject generatorSettings, boolean generateStructures, String levelType) {
 
         /*
         private final String levelSeed;
@@ -177,6 +177,11 @@ public class DedicatedServerProperties extends Settings<DedicatedServerPropertie
             return this.levelSeed;
         }
 
+        // Matter
+        public String featureSeed() {
+            return this.featureSeed;
+        }
+
         public JsonObject generatorSettings() {
             return this.generatorSettings;
         }
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 168f4e3d50fb5ea6aee5340edafe27794bc64a9b..6eba2ace94573d17ca1600646cd9917094f7af4d 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -47,6 +47,7 @@ import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelData;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
+import su.plo.matter.Globals; // Matter
 
 public class ServerChunkCache extends ChunkSource {
 
@@ -1139,6 +1140,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public ChunkGenerator getGenerator() {
+        Globals.INSTANCE.setupGlobals(level);
         return this.chunkMap.generator();
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index b138a583ce7f46ff99041b23ef4d442f98650a59..fa5e6bcc61ccb5467c0b7b4d478922b254c9f245 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -162,6 +162,7 @@ import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
+import su.plo.matter.Globals; // Matter
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
@@ -533,6 +534,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         }
         chunkgenerator.conf = spigotConfig; // Spigot
         // CraftBukkit end
+        Globals.INSTANCE.setupGlobals(this);
         chunkgenerator.ensureStructuresGenerated();
         boolean flag2 = minecraftserver.forceSynchronousWrites();
         DataFixer datafixer = minecraftserver.getFixerUpper();
diff --git a/src/main/java/net/minecraft/world/entity/monster/Slime.java b/src/main/java/net/minecraft/world/entity/monster/Slime.java
index 29b56001fdb44bc5267d2d2ae8e9bafc61b3fe79..2b189b6de91069445b02c486dde289175e9b7bf5 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Slime.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Slime.java
@@ -421,7 +421,7 @@ public class Slime extends Mob implements Enemy {
             }
 
             ChunkPos chunkcoordintpair = new ChunkPos(pos);
-            boolean flag = world.getMinecraftWorld().paperConfig.allChunksAreSlimeChunks || WorldgenRandom.seedSlimeChunk(chunkcoordintpair.x, chunkcoordintpair.z, ((WorldGenLevel) world).getSeed(), world.getMinecraftWorld().spigotConfig.slimeSeed).nextInt(10) == 0; // Spigot // Paper
+            boolean flag = world.getMinecraftWorld().paperConfig.allChunksAreSlimeChunks || world.getChunk(chunkcoordintpair.x, chunkcoordintpair.z).isSlimeChunk(); // Spigot // Paper // Matter
 
             // Paper start - Replace rules for Height in Slime Chunks
             final double maxHeightSlimeChunk = world.getMinecraftWorld().paperConfig.slimeMaxSpawnHeightInSlimeChunks;
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index 08433670b54c67319ce13ac3ef0f24bd3f819ea0..6c41daa15a802deb53e738a3210013a30fa8ce3e 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -53,6 +53,7 @@ import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.ticks.SerializableTickContainer;
 import net.minecraft.world.ticks.TickContainerAccess;
 import org.slf4j.Logger;
+import su.plo.matter.WorldgenCryptoRandom; // Matter
 
 public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiomeSource, FeatureAccess {
 
@@ -80,6 +81,10 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
     protected final LevelHeightAccessor levelHeightAccessor;
     protected final LevelChunkSection[] sections;
 
+    // Matter start
+    private boolean slimeChunk;
+    private boolean hasComputedSlimeChunk;
+
     // CraftBukkit start - SPIGOT-6814: move to IChunkAccess to account for 1.17 to 1.18 chunk upgrading.
     private static final org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry();
     public org.bukkit.craftbukkit.persistence.DirtyCraftPersistentDataContainer persistentDataContainer = new org.bukkit.craftbukkit.persistence.DirtyCraftPersistentDataContainer(ChunkAccess.DATA_TYPE_REGISTRY);
@@ -150,6 +155,17 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
     public final Registry<Biome> biomeRegistry;
     // CraftBukkit end
 
+    // Matter start
+    public boolean isSlimeChunk() {
+        if (!hasComputedSlimeChunk) {
+            hasComputedSlimeChunk = true;
+            slimeChunk = WorldgenCryptoRandom.Companion.seedSlimeChunk(chunkPos.x, chunkPos.z).nextInt(10) == 0;
+        }
+
+        return slimeChunk;
+    }
+    // Matter end
+
     private static void replaceMissingSections(LevelHeightAccessor world, Registry<Biome> biome, LevelChunkSection[] sectionArray) {
         for (int i = 0; i < sectionArray.length; ++i) {
             if (sectionArray[i] == null) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
index 2672786fc481845085812afb759a8870c20da079..08c32982ea8a7f8f3bc54c82eb51dc87c0638694 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -86,6 +86,10 @@ import net.minecraft.world.level.levelgen.structure.placement.StructurePlacement
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
 import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.slf4j.Logger;
+// Matter start
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+// Matter end
 
 public abstract class ChunkGenerator implements BiomeManager.NoiseBiomeSource {
 
@@ -229,7 +233,7 @@ public abstract class ChunkGenerator implements BiomeManager.NoiseBiomeSource {
             int i = concentricringsstructureplacement.distance();
             int j = concentricringsstructureplacement.count();
             int k = concentricringsstructureplacement.spread();
-            Random random = new Random();
+            Random random = new WorldgenCryptoRandom(0, 0, Globals.Salt.STRONGHOLDS, 0); // Matter
 
             // Paper start
             if (this.conf.strongholdSeed != null && this.structureSets.getResourceKey(holder).orElse(null) == net.minecraft.world.level.levelgen.structure.BuiltinStructureSets.STRONGHOLDS) {
@@ -511,8 +515,12 @@ public abstract class ChunkGenerator implements BiomeManager.NoiseBiomeSource {
                 return structurefeature.feature.step().ordinal();
             }));
             List<BiomeSource.StepFeatureData> list = this.biomeSource.featuresPerStep();
-            WorldgenRandom seededrandom = new WorldgenRandom(new XoroshiroRandomSource(RandomSupport.seedUniquifier()));
+            // Matter start
+            WorldgenRandom seededrandom = new WorldgenCryptoRandom(
+                blockposition.getX(), blockposition.getZ(), Globals.Salt.UNDEFINED, 0
+            );
             long i = seededrandom.setDecorationSeed(generatoraccessseed.getSeed(), blockposition.getX(), blockposition.getZ());
+            // Matter end
             Set<Biome> set = new ObjectArraySet();
 
             if (this instanceof FlatLevelSource) {
@@ -786,9 +794,11 @@ public abstract class ChunkGenerator implements BiomeManager.NoiseBiomeSource {
                     ArrayList<StructureSet.StructureSelectionEntry> arraylist = new ArrayList(list.size());
 
                     arraylist.addAll(list);
-                    WorldgenRandom seededrandom = new WorldgenRandom(new LegacyRandomSource(0L));
-
-                    seededrandom.setLargeFeatureSeed(worldSeed, chunkcoordintpair.x, chunkcoordintpair.z);
+                    // Matter start
+                    WorldgenRandom seededrandom = new WorldgenCryptoRandom(
+                        chunkcoordintpair.x, chunkcoordintpair.z, Globals.Salt.GENERATE_FEATURE, 0
+                    );
+                    // Matter end
                     int j = 0;
 
                     StructureSet.StructureSelectionEntry structureset_a1;
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
index f760f598e9fd4c2a72059334ff7ea5dbdee37696..caf017fb8960c2dc12797479f144ea8c274081e2 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
@@ -27,6 +27,7 @@ import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.blending.Blender;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
 import java.util.ArrayList; // Mirai - c2me: worldgen vanilla bugs fixes
+import su.plo.matter.Globals; // Matter
 
 public class ChunkStatus {
 
@@ -269,6 +270,7 @@ public class ChunkStatus {
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> generate(Executor executor, ServerLevel world, ChunkGenerator generator, StructureManager structureManager, ThreadedLevelLightEngine lightingProvider, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> fullChunkConverter, List<ChunkAccess> chunks, boolean flag) {
+        Globals.INSTANCE.setupGlobals(world); // Matter
         ChunkAccess ichunkaccess = (ChunkAccess) chunks.get(chunks.size() / 2);
         ProfiledDuration profiledduration = JvmProfiler.INSTANCE.onChunkGenerate(ichunkaccess.getPos(), world.dimension(), this.name);
         CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.generationTask.doWork(this, executor, world, generator, structureManager, lightingProvider, fullChunkConverter, chunks, ichunkaccess, flag);
diff --git a/src/main/java/net/minecraft/world/level/levelgen/WorldGenSettings.java b/src/main/java/net/minecraft/world/level/levelgen/WorldGenSettings.java
index 61dc7d594c4ee15f99fd531d1b2cbaffc63c372d..a31984b46cd1a25605a6e7e93e836227e2474e4b 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/WorldGenSettings.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/WorldGenSettings.java
@@ -16,6 +16,7 @@ import java.util.Optional;
 import java.util.OptionalLong;
 import java.util.Random;
 import java.util.function.Function;
+import java.util.stream.LongStream; // Matter
 import net.minecraft.core.Holder;
 import net.minecraft.core.MappedRegistry;
 import net.minecraft.core.Registry;
@@ -36,16 +37,23 @@ import net.minecraft.world.level.levelgen.structure.StructureSet;
 import net.minecraft.world.level.levelgen.synth.NormalNoise;
 import org.apache.commons.lang3.StringUtils;
 import org.slf4j.Logger;
+import su.plo.matter.Globals; // Matter
 
 public class WorldGenSettings {
-
-    public static final Codec<WorldGenSettings> CODEC = RecordCodecBuilder.<WorldGenSettings>create((instance) -> { // CraftBukkit - decompile error
-        return instance.group(Codec.LONG.fieldOf("seed").stable().forGetter(WorldGenSettings::seed), Codec.BOOL.fieldOf("generate_features").orElse(true).stable().forGetter(WorldGenSettings::generateFeatures), Codec.BOOL.fieldOf("bonus_chest").orElse(false).stable().forGetter(WorldGenSettings::generateBonusChest), RegistryCodecs.dataPackAwareCodec(Registry.LEVEL_STEM_REGISTRY, Lifecycle.stable(), LevelStem.CODEC).xmap(LevelStem::sortMap, Function.identity()).fieldOf("dimensions").forGetter(WorldGenSettings::dimensions), Codec.STRING.optionalFieldOf("legacy_custom_options").stable().forGetter((generatorsettings) -> {
-            return generatorsettings.legacyCustomOptions;
-        })).apply(instance, instance.stable(WorldGenSettings::new));
+    // Matter start
+    public static final Codec<WorldGenSettings> CODEC = RecordCodecBuilder.<WorldGenSettings>create((instance) -> {
+        return instance.group(Codec.LONG.fieldOf("seed").stable().forGetter(WorldGenSettings::seed),
+            Codec.LONG_STREAM.fieldOf("feature_seed").stable().forGetter((settings) -> LongStream.of(settings.featureSeed())), // Matter
+            Codec.BOOL.fieldOf("generate_features").orElse(true).stable().forGetter(WorldGenSettings::generateFeatures),
+            Codec.BOOL.fieldOf("bonus_chest").orElse(false).stable().forGetter(WorldGenSettings::generateBonusChest),
+            RegistryCodecs.dataPackAwareCodec(Registry.LEVEL_STEM_REGISTRY, Lifecycle.stable(), LevelStem.CODEC).xmap(LevelStem::sortMap, Function.identity()).fieldOf("dimensions").forGetter(WorldGenSettings::dimensions),
+            Codec.STRING.optionalFieldOf("legacy_custom_options").stable().forGetter((WorldGenSettings worldGenSettings) -> {
+                return worldGenSettings.legacyCustomOptions;
+            })).apply(instance, instance.stable(WorldGenSettings::new));
     }).comapFlatMap(WorldGenSettings::guardExperimental, Function.identity());
     private static final Logger LOGGER = LogUtils.getLogger();
     private final long seed;
+    private final long[] featureSeed; // Matter
     private final boolean generateFeatures;
     private final boolean generateBonusChest;
     private final Registry<LevelStem> dimensions;
@@ -61,33 +69,39 @@ public class WorldGenSettings {
         return LevelStem.stable(this.seed, this.dimensions);
     }
 
-    public WorldGenSettings(long seed, boolean generateStructures, boolean bonusChest, Registry<LevelStem> options) {
-        this(seed, generateStructures, bonusChest, options, Optional.empty());
-        LevelStem worlddimension = (LevelStem) options.get(LevelStem.OVERWORLD);
+    public WorldGenSettings(long seed, long[] featureSeed, boolean generateStructures, boolean bonusChest, Registry<LevelStem> options) {
+        this(seed, featureSeed, generateStructures, bonusChest, options, Optional.empty());
+        LevelStem levelStem = options.get(LevelStem.OVERWORLD);
 
-        if (worlddimension == null) {
+        if (levelStem == null) {
             throw new IllegalStateException("Overworld settings missing");
         }
     }
 
-    private WorldGenSettings(long seed, boolean generateStructures, boolean bonusChest, Registry<LevelStem> options, Optional<String> legacyCustomOptions) {
+    private WorldGenSettings(long seed, LongStream featureSeed, boolean generateStructures, boolean bonusChest, Registry<LevelStem> options, Optional<String> legacyCustomOptions) {
+        this(seed, featureSeed.toArray(), generateStructures, bonusChest, options, legacyCustomOptions);
+    }
+
+    private WorldGenSettings(long seed, long[] featureSeed, boolean generateStructures, boolean bonusChest, Registry<LevelStem> options, Optional<String> legacyCustomOptions) {
         this.seed = seed;
+        this.featureSeed = featureSeed;
         this.generateFeatures = generateStructures;
         this.generateBonusChest = bonusChest;
         this.dimensions = options;
         this.legacyCustomOptions = legacyCustomOptions;
     }
+    // Matter end
 
     public static WorldGenSettings demoSettings(RegistryAccess registryManager) {
         int i = "North Carolina".hashCode();
 
-        return new WorldGenSettings((long) i, true, true, WorldGenSettings.withOverworld(registryManager.registryOrThrow(Registry.DIMENSION_TYPE_REGISTRY), DimensionType.defaultDimensions(registryManager, (long) i), WorldGenSettings.makeDefaultOverworld(registryManager, (long) i)));
+        return new WorldGenSettings(i, Globals.INSTANCE.parseSeed("North Carolina").get(), true, true, WorldGenSettings.withOverworld(registryManager.registryOrThrow(Registry.DIMENSION_TYPE_REGISTRY), DimensionType.defaultDimensions(registryManager, i), WorldGenSettings.makeDefaultOverworld(registryManager, i))); // Matter
     }
 
     public static WorldGenSettings makeDefault(RegistryAccess registryManager) {
         long i = (new Random()).nextLong();
 
-        return new WorldGenSettings(i, true, false, WorldGenSettings.withOverworld(registryManager.registryOrThrow(Registry.DIMENSION_TYPE_REGISTRY), DimensionType.defaultDimensions(registryManager, i), WorldGenSettings.makeDefaultOverworld(registryManager, i)));
+        return new WorldGenSettings(i, Globals.INSTANCE.createRandomWorldSeed(), true, false, WorldGenSettings.withOverworld(registryManager.registryOrThrow(Registry.DIMENSION_TYPE_REGISTRY), DimensionType.defaultDimensions(registryManager, i), WorldGenSettings.makeDefaultOverworld(registryManager, i))); // Matter
     }
 
     public static NoiseBasedChunkGenerator makeDefaultOverworld(RegistryAccess registryManager, long seed) {
@@ -115,6 +129,12 @@ public class WorldGenSettings {
         return this.seed;
     }
 
+    // Matter start
+    public long[] featureSeed() {
+        return this.featureSeed;
+    }
+    // Matter end
+
     public boolean generateFeatures() {
         return this.generateFeatures;
     }
@@ -187,18 +207,19 @@ public class WorldGenSettings {
     }
 
     public WorldGenSettings withBonusChest() {
-        return new WorldGenSettings(this.seed, this.generateFeatures, true, this.dimensions, this.legacyCustomOptions);
+        return new WorldGenSettings(this.seed, this.featureSeed, this.generateFeatures, true, this.dimensions, this.legacyCustomOptions); // Matter
     }
 
     public WorldGenSettings withFeaturesToggled() {
-        return new WorldGenSettings(this.seed, !this.generateFeatures, this.generateBonusChest, this.dimensions);
+        return new WorldGenSettings(this.seed, this.featureSeed, !this.generateFeatures, this.generateBonusChest, this.dimensions); // Matter
     }
 
     public WorldGenSettings withBonusChestToggled() {
-        return new WorldGenSettings(this.seed, this.generateFeatures, !this.generateBonusChest, this.dimensions);
+        return new WorldGenSettings(this.seed, this.featureSeed, this.generateFeatures, !this.generateBonusChest, this.dimensions); // Matter
     }
 
     public static WorldGenSettings create(RegistryAccess registryManager, DedicatedServerProperties.WorldGenProperties worldGenProperties) {
+        long[] featureSeed = Globals.INSTANCE.parseSeed(worldGenProperties.featureSeed()).orElse(Globals.INSTANCE.createRandomWorldSeed()); // Matter
         long i = WorldGenSettings.parseSeed(worldGenProperties.levelSeed()).orElse((new Random()).nextLong());
         Registry<DimensionType> iregistry = registryManager.registryOrThrow(Registry.DIMENSION_TYPE_REGISTRY);
         Registry<Biome> iregistry1 = registryManager.registryOrThrow(Registry.BIOME_REGISTRY);
@@ -237,17 +258,17 @@ public class WorldGenSettings {
                 Logger logger = WorldGenSettings.LOGGER;
 
                 Objects.requireNonNull(logger);
-                return new WorldGenSettings(i, flag, false, WorldGenSettings.withOverworld(iregistry, iregistry3, new FlatLevelSource(iregistry2, (FlatLevelGeneratorSettings) dataresult.resultOrPartial(s1 -> logger.error(String.valueOf(s1))).orElseGet(() -> { // CraftBukkit - decompile error
+                return new WorldGenSettings(i, featureSeed, flag, false, WorldGenSettings.withOverworld(iregistry, iregistry3, new FlatLevelSource(iregistry2, (FlatLevelGeneratorSettings) dataresult.resultOrPartial(s1 -> logger.error(String.valueOf(s1))).orElseGet(() -> { // CraftBukkit - decompile error // Matter
                     return FlatLevelGeneratorSettings.getDefault(iregistry1, iregistry2);
                 }))));
             case 1:
-                return new WorldGenSettings(i, worldGenProperties.generateStructures(), false, WorldGenSettings.withOverworld(iregistry, iregistry3, new DebugLevelSource(iregistry2, iregistry1)));
+                return new WorldGenSettings(i, featureSeed, worldGenProperties.generateStructures(), false, WorldGenSettings.withOverworld(iregistry, iregistry3, new DebugLevelSource(iregistry2, iregistry1))); // Matter
             case 2:
-                return new WorldGenSettings(i, worldGenProperties.generateStructures(), false, WorldGenSettings.withOverworld(iregistry, iregistry3, WorldGenSettings.makeOverworld(registryManager, i, NoiseGeneratorSettings.AMPLIFIED)));
+                return new WorldGenSettings(i, featureSeed, worldGenProperties.generateStructures(), false, WorldGenSettings.withOverworld(iregistry, iregistry3, WorldGenSettings.makeOverworld(registryManager, i, NoiseGeneratorSettings.AMPLIFIED))); // Matter
             case 3:
-                return new WorldGenSettings(i, worldGenProperties.generateStructures(), false, WorldGenSettings.withOverworld(iregistry, iregistry3, WorldGenSettings.makeOverworld(registryManager, i, NoiseGeneratorSettings.LARGE_BIOMES)));
+                return new WorldGenSettings(i, featureSeed, worldGenProperties.generateStructures(), false, WorldGenSettings.withOverworld(iregistry, iregistry3, WorldGenSettings.makeOverworld(registryManager, i, NoiseGeneratorSettings.LARGE_BIOMES))); // Matter
             default:
-                return new WorldGenSettings(i, worldGenProperties.generateStructures(), false, WorldGenSettings.withOverworld(iregistry, iregistry3, WorldGenSettings.makeDefaultOverworld(registryManager, i)));
+                return new WorldGenSettings(i, featureSeed, worldGenProperties.generateStructures(), false, WorldGenSettings.withOverworld(iregistry, iregistry3, WorldGenSettings.makeDefaultOverworld(registryManager, i))); // Matter
         }
     }
 
@@ -255,6 +276,8 @@ public class WorldGenSettings {
         long i = seed.orElse(this.seed);
         Object object;
 
+        long[] featureSeed = Globals.INSTANCE.createRandomWorldSeed();
+
         if (seed.isPresent()) {
             WritableRegistry<LevelStem> iregistrywritable = new MappedRegistry<>(Registry.LEVEL_STEM_REGISTRY, Lifecycle.experimental(), (Function) null);
             long j = seed.getAsLong();
@@ -275,9 +298,9 @@ public class WorldGenSettings {
         WorldGenSettings generatorsettings;
 
         if (this.isDebug()) {
-            generatorsettings = new WorldGenSettings(i, false, false, (Registry) object);
+            generatorsettings = new WorldGenSettings(i, featureSeed, false, false, (Registry) object); // Matter
         } else {
-            generatorsettings = new WorldGenSettings(i, this.generateFeatures(), this.generateBonusChest() && !hardcore, (Registry) object);
+            generatorsettings = new WorldGenSettings(i, featureSeed, this.generateFeatures(), this.generateBonusChest() && !hardcore, (Registry) object); // Matter
         }
 
         return generatorsettings;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/BuriedTreasureFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/BuriedTreasureFeature.java
index e4201731cee6ffd14a00370666de8cee5d2d5872..2a714035c14e7ab1f2a2a9b242cb8cbe8c88e6d2 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/BuriedTreasureFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/BuriedTreasureFeature.java
@@ -3,13 +3,17 @@ package net.minecraft.world.level.levelgen.feature;
 import com.mojang.serialization.Codec;
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.level.levelgen.Heightmap;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
+import net.minecraft.world.level.levelgen.WorldGenSettings;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.ProbabilityFeatureConfiguration;
 import net.minecraft.world.level.levelgen.structure.BuriedTreasurePieces;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder;
+// Matter start
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+// Matter end
 
 public class BuriedTreasureFeature extends StructureFeature<ProbabilityFeatureConfiguration> {
     private static final int RANDOM_SALT = 10387320;
@@ -19,11 +23,11 @@ public class BuriedTreasureFeature extends StructureFeature<ProbabilityFeatureCo
     }
 
     private static boolean checkLocation(PieceGeneratorSupplier.Context<ProbabilityFeatureConfiguration> context) {
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        // Purpur start
-        int salt = org.purpurmc.purpur.PurpurConfig.seedStructureBuriedTreasure;
-        worldgenRandom.setLargeFeatureWithSalt(context.seed(), context.chunkPos().x, context.chunkPos().z, salt != -1 ? salt : RANDOM_SALT);
-        // Purpur end
+        // Matter start
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+            context.chunkPos().x, context.chunkPos().z, Globals.Salt.BURIED_TREASURE_FEATURE, 0
+        );
+        // Matter end
         return worldgenRandom.nextFloat() < (context.config()).probability && context.validBiomeOnTop(Heightmap.Types.OCEAN_FLOOR_WG);
     }
 
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredStructureFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredStructureFeature.java
index 473a54963fbe08beeff26a828827f9f72d8a29b8..7ba23f979fcd84c13cf6d647194bf17132c5291c 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredStructureFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredStructureFeature.java
@@ -26,6 +26,10 @@ import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
+// Matter start
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+// Matter end
 
 public class ConfiguredStructureFeature<FC extends FeatureConfiguration, F extends StructureFeature<FC>> {
     public static final Codec<ConfiguredStructureFeature<?, ?>> DIRECT_CODEC = Registry.STRUCTURE_FEATURE.byNameCodec().dispatch((configuredStructureFeature) -> {
@@ -52,8 +56,11 @@ public class ConfiguredStructureFeature<FC extends FeatureConfiguration, F exten
         Optional<PieceGenerator<FC>> optional = this.feature.pieceGeneratorSupplier().createGenerator(new PieceGeneratorSupplier.Context<>(chunkGenerator, biomeSource, worldSeed, chunkPos, this.config, world, biomePredicate, structureManager, registryManager));
         if (optional.isPresent()) {
             StructurePiecesBuilder structurePiecesBuilder = new StructurePiecesBuilder();
-            WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-            worldgenRandom.setLargeFeatureSeed(worldSeed, chunkPos.x, chunkPos.z);
+            // Matter start
+            WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+                chunkPos.x, chunkPos.z, Globals.Salt.GENERATE_FEATURE, 0
+            );
+            // Matter end
             optional.get().generatePieces(structurePiecesBuilder, new PieceGenerator.Context<>(this.config, chunkGenerator, structureManager, chunkPos, world, worldgenRandom, worldSeed));
             StructureStart structureStart = new StructureStart(this, chunkPos, structureReferences, structurePiecesBuilder.build());
             if (structureStart.isValid()) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java
index 24110d4d412b5bd0a6c17215b889ea6c02558a2c..ae57e0da2d744b4a919a5d5cef6da89f517ff106 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java
@@ -19,11 +19,14 @@ import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.levelgen.GeodeBlockSettings;
 import net.minecraft.world.level.levelgen.GeodeCrackSettings;
 import net.minecraft.world.level.levelgen.GeodeLayerSettings;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration;
 import net.minecraft.world.level.levelgen.synth.NormalNoise;
 import net.minecraft.world.level.material.FluidState;
+// Matter start
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+// Matter end
 
 public class GeodeFeature extends Feature<GeodeConfiguration> {
     private static final Direction[] DIRECTIONS = Direction.values();
@@ -42,7 +45,7 @@ public class GeodeFeature extends Feature<GeodeConfiguration> {
         int j = geodeConfiguration.maxGenOffset;
         List<Pair<BlockPos, Integer>> list = Lists.newLinkedList();
         int k = geodeConfiguration.distributionPoints.sample(random);
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(worldGenLevel.getSeed()));
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(0, 0, Globals.Salt.GEODE_FEATURE, 0); // Matter
         NormalNoise normalNoise = NormalNoise.create(worldgenRandom, -4, 1.0D);
         List<BlockPos> list2 = Lists.newLinkedList();
         double d = (double)k / (double)geodeConfiguration.outerWallDistance.getMaxValue();
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/MineshaftFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/MineshaftFeature.java
index 354a923350cbfc76645136858e8e96285de139a1..2436c7a16afb1c086a00b175beabe8d115ee112c 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/MineshaftFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/MineshaftFeature.java
@@ -12,13 +12,16 @@ import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.levelgen.Heightmap;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.MineshaftConfiguration;
 import net.minecraft.world.level.levelgen.structure.MineShaftPieces;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder;
+// Matter start
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+// Matter end
 
 public class MineshaftFeature extends StructureFeature<MineshaftConfiguration> {
     public MineshaftFeature(Codec<MineshaftConfiguration> configCodec) {
@@ -26,7 +29,11 @@ public class MineshaftFeature extends StructureFeature<MineshaftConfiguration> {
     }
 
     private static boolean checkLocation(PieceGeneratorSupplier.Context<MineshaftConfiguration> context) {
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
+        // Matter start
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(
+            context.chunkPos().x, context.chunkPos().z, Globals.Salt.MINESHAFT_FEATURE, 0
+        );
+        // Matter end
         // Purpur start
         int salt = org.purpurmc.purpur.PurpurConfig.seedStructureMineshaft;
         if (salt != -1) worldgenRandom.setLargeFeatureWithSalt(context.seed(), context.chunkPos().x, context.chunkPos().z, salt); else
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/NetherFortressFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/NetherFortressFeature.java
index 8c92b50a5aaad7d70b6e4c793b9746d29d41afa4..e3ea900364fd1a806b8f8c4d2739178a82e30447 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/NetherFortressFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/NetherFortressFeature.java
@@ -6,12 +6,17 @@ import net.minecraft.core.QuartPos;
 import net.minecraft.util.random.WeightedRandomList;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.level.biome.MobSpawnSettings;
+import net.minecraft.world.level.levelgen.WorldgenRandom; // Matter
 import net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration;
 import net.minecraft.world.level.levelgen.structure.NetherBridgePieces;
 import net.minecraft.world.level.levelgen.structure.StructurePiece;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder;
+// Matter start
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+// Matter end
 
 public class NetherFortressFeature extends StructureFeature<NoneFeatureConfiguration> {
     public static final WeightedRandomList<MobSpawnSettings.SpawnerData> FORTRESS_ENEMIES = WeightedRandomList.create(new MobSpawnSettings.SpawnerData(EntityType.BLAZE, 10, 2, 3), new MobSpawnSettings.SpawnerData(EntityType.ZOMBIFIED_PIGLIN, 5, 4, 4), new MobSpawnSettings.SpawnerData(EntityType.WITHER_SKELETON, 8, 5, 5), new MobSpawnSettings.SpawnerData(EntityType.SKELETON, 2, 5, 5), new MobSpawnSettings.SpawnerData(EntityType.MAGMA_CUBE, 3, 4, 4));
@@ -21,7 +26,10 @@ public class NetherFortressFeature extends StructureFeature<NoneFeatureConfigura
     }
 
     private static boolean checkLocation(PieceGeneratorSupplier.Context<NoneFeatureConfiguration> context) {
-        return context.validBiome().test(context.chunkGenerator().getNoiseBiome(QuartPos.fromBlock(context.chunkPos().getMiddleBlockX()), QuartPos.fromBlock(64), QuartPos.fromBlock(context.chunkPos().getMiddleBlockZ())));
+        // Matter start
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(context.chunkPos().x, context.chunkPos().z, Globals.Salt.NETHER_FORTRESS_FEATURE, 0);
+        return worldgenRandom.nextInt(5) < 2 && context.validBiome().test(context.chunkGenerator().getNoiseBiome(QuartPos.fromBlock(context.chunkPos().getMiddleBlockX()), QuartPos.fromBlock(64), QuartPos.fromBlock(context.chunkPos().getMiddleBlockZ())));
+        // Matter end
     }
 
     private static void generatePieces(StructurePiecesBuilder collector, PieceGenerator.Context<NoneFeatureConfiguration> context) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/OceanMonumentFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/OceanMonumentFeature.java
index 3e5a6afa03e659c14105d95194e2e4fa52feb841..859edb57c13aad06c60a19760c860d6816d939ac 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/OceanMonumentFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/OceanMonumentFeature.java
@@ -7,8 +7,6 @@ import net.minecraft.core.Holder;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.biome.Biome;
 import net.minecraft.world.level.levelgen.Heightmap;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
-import net.minecraft.world.level.levelgen.RandomSupport;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
@@ -18,6 +16,10 @@ import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
 import net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder;
+// Matter start
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+// Matter end
 
 public class OceanMonumentFeature extends StructureFeature<NoneFeatureConfiguration> {
     public OceanMonumentFeature(Codec<NoneFeatureConfiguration> configCodec) {
@@ -52,7 +54,7 @@ public class OceanMonumentFeature extends StructureFeature<NoneFeatureConfigurat
         if (pieces.isEmpty()) {
             return pieces;
         } else {
-            WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(RandomSupport.seedUniquifier()));
+            WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(pos.x, pos.z, Globals.Salt.OCEAN_MONUMENT_FEATURE, 0); // Matter
             worldgenRandom.setLargeFeatureSeed(worldSeed, pos.x, pos.z);
             StructurePiece structurePiece = pieces.pieces().get(0);
             BoundingBox boundingBox = structurePiece.getBoundingBox();
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/PillagerOutpostFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/PillagerOutpostFeature.java
index 043233f496ce7e03aa3977f9f8c165924ff0da5f..ec5a76c68609327087ee6c3ee2614ce3a82c0676 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/PillagerOutpostFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/PillagerOutpostFeature.java
@@ -2,11 +2,14 @@ package net.minecraft.world.level.levelgen.feature;
 
 import com.mojang.serialization.Codec;
 import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.JigsawConfiguration;
 import net.minecraft.world.level.levelgen.structure.BuiltinStructureSets;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
+// Matter
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+// Matter
 
 public class PillagerOutpostFeature extends JigsawFeature {
     public PillagerOutpostFeature(Codec<JigsawConfiguration> configCodec) {
@@ -17,8 +20,7 @@ public class PillagerOutpostFeature extends JigsawFeature {
         ChunkPos chunkPos = context.chunkPos();
         int i = chunkPos.x >> 4;
         int j = chunkPos.z >> 4;
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setSeed((long)(i ^ j << 4) ^ context.seed());
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(i, j, Globals.Salt.PILLAGER_OUTPOST_FEATURE, 0); // Matter
         worldgenRandom.nextInt();
         if (worldgenRandom.nextInt(5) != 0) {
             return false;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/RuinedPortalFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/RuinedPortalFeature.java
index 75e6ee90137e17ffc25fcf987df93ccba14add02..37ece6ff42983a652f45fa3b11ff1448ce22e16c 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/RuinedPortalFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/RuinedPortalFeature.java
@@ -2,11 +2,7 @@ package net.minecraft.world.level.levelgen.feature;
 
 import com.google.common.collect.ImmutableList;
 import com.mojang.serialization.Codec;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Random;
+import java.util.*; // Matter
 import java.util.stream.Collectors;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
@@ -23,7 +19,6 @@ import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.levelgen.Heightmap;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.RuinedPortalConfiguration;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
@@ -31,6 +26,10 @@ import net.minecraft.world.level.levelgen.structure.RuinedPortalPiece;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate;
+// Matter start
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+// Matter end
 
 public class RuinedPortalFeature extends StructureFeature<RuinedPortalConfiguration> {
     private static final String[] STRUCTURE_LOCATION_PORTALS = new String[]{"ruined_portal/portal_1", "ruined_portal/portal_2", "ruined_portal/portal_3", "ruined_portal/portal_4", "ruined_portal/portal_5", "ruined_portal/portal_6", "ruined_portal/portal_7", "ruined_portal/portal_8", "ruined_portal/portal_9", "ruined_portal/portal_10"};
@@ -50,8 +49,7 @@ public class RuinedPortalFeature extends StructureFeature<RuinedPortalConfigurat
     private static Optional<PieceGenerator<RuinedPortalConfiguration>> pieceGeneratorSupplier(PieceGeneratorSupplier.Context<RuinedPortalConfiguration> context) {
         RuinedPortalPiece.Properties properties = new RuinedPortalPiece.Properties();
         RuinedPortalConfiguration ruinedPortalConfiguration = context.config();
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setLargeFeatureSeed(context.seed(), context.chunkPos().x, context.chunkPos().z);
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(context.chunkPos().x, context.chunkPos().z, Globals.Salt.RUINED_PORTAL_FEATURE, 0); // Matter
         RuinedPortalPiece.VerticalPlacement verticalPlacement;
         if (ruinedPortalConfiguration.portalType == RuinedPortalFeature.Type.DESERT) {
             verticalPlacement = RuinedPortalPiece.VerticalPlacement.PARTLY_BURIED;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/WoodlandMansionFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/WoodlandMansionFeature.java
index 3607b5b63b28591e2bfb6ee760df29bf8dab0ae8..58cfa906372cc4830957a9cf61428089519f9a0c 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/WoodlandMansionFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/WoodlandMansionFeature.java
@@ -13,7 +13,6 @@ import net.minecraft.world.level.WorldGenLevel;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.chunk.ChunkGenerator;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
@@ -21,6 +20,10 @@ import net.minecraft.world.level.levelgen.structure.WoodlandMansionPieces;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
 import net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer;
+// Matter start
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+// Matter end
 
 public class WoodlandMansionFeature extends StructureFeature<NoneFeatureConfiguration> {
     public WoodlandMansionFeature(Codec<NoneFeatureConfiguration> configCodec) {
@@ -28,8 +31,7 @@ public class WoodlandMansionFeature extends StructureFeature<NoneFeatureConfigur
     }
 
     private static Optional<PieceGenerator<NoneFeatureConfiguration>> pieceGeneratorSupplier(PieceGeneratorSupplier.Context<NoneFeatureConfiguration> context) {
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setLargeFeatureSeed(context.seed(), context.chunkPos().x, context.chunkPos().z);
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(context.chunkPos().x, context.chunkPos().z, Globals.Salt.WOODLAND_MANSION_FEATURE, 0); // Matter
         Rotation rotation = Rotation.getRandom(worldgenRandom);
         int i = 5;
         int j = 5;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/NetherFossilFeature.java b/src/main/java/net/minecraft/world/level/levelgen/structure/NetherFossilFeature.java
index fc6ea073dda463a0d0fcdc2c40b1b6ef2339c6af..1e1cf1d0d9dcc675b41fdd938a612b479d31d574 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/NetherFossilFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/NetherFossilFeature.java
@@ -9,13 +9,16 @@ import net.minecraft.world.level.EmptyBlockGetter;
 import net.minecraft.world.level.NoiseColumn;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldGenerationContext;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.StructureFeature;
 import net.minecraft.world.level.levelgen.feature.configurations.RangeConfiguration;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGenerator;
 import net.minecraft.world.level.levelgen.structure.pieces.PieceGeneratorSupplier;
+// Matter start
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+// Matter end
 
 public class NetherFossilFeature extends StructureFeature<RangeConfiguration> {
     public NetherFossilFeature(Codec<RangeConfiguration> configCodec) {
@@ -23,8 +26,7 @@ public class NetherFossilFeature extends StructureFeature<RangeConfiguration> {
     }
 
     private static Optional<PieceGenerator<RangeConfiguration>> pieceGeneratorSupplier(PieceGeneratorSupplier.Context<RangeConfiguration> context) {
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setLargeFeatureSeed(context.seed(), context.chunkPos().x, context.chunkPos().z);
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(context.chunkPos().x, context.chunkPos().z, Globals.Salt.NETHER_FOSSIL_FEATURE, 0); // Matter
         int i = context.chunkPos().getMinBlockX() + worldgenRandom.nextInt(16);
         int j = context.chunkPos().getMinBlockZ() + worldgenRandom.nextInt(16);
         int k = context.chunkGenerator().getSeaLevel();
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/placement/RandomSpreadStructurePlacement.java b/src/main/java/net/minecraft/world/level/levelgen/structure/placement/RandomSpreadStructurePlacement.java
index 42152827c5b1393c9b7efa88017435716eb585c0..7f7873d3b0f38d3c42725da50e6566bda1a42e7e 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/placement/RandomSpreadStructurePlacement.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/placement/RandomSpreadStructurePlacement.java
@@ -7,15 +7,18 @@ import net.minecraft.core.Vec3i;
 import net.minecraft.util.ExtraCodecs;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.ChunkGenerator;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
+// Matter start
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+// Matter end
 
 public record RandomSpreadStructurePlacement(int spacing, int separation, RandomSpreadType spreadType, int salt, Vec3i locateOffset) implements StructurePlacement {
-    public static final Codec<RandomSpreadStructurePlacement> CODEC = RecordCodecBuilder.mapCodec((instance) -> {
+    // Matter start - compile fix
+    public static final Codec<RandomSpreadStructurePlacement> CODEC = RecordCodecBuilder.<RandomSpreadStructurePlacement>mapCodec((instance) -> {
         return instance.group(Codec.intRange(0, 4096).fieldOf("spacing").forGetter(RandomSpreadStructurePlacement::spacing), Codec.intRange(0, 4096).fieldOf("separation").forGetter(RandomSpreadStructurePlacement::separation), RandomSpreadType.CODEC.optionalFieldOf("spread_type", RandomSpreadType.LINEAR).forGetter(RandomSpreadStructurePlacement::spreadType), ExtraCodecs.NON_NEGATIVE_INT.fieldOf("salt").forGetter(RandomSpreadStructurePlacement::salt), Vec3i.offsetCodec(16).optionalFieldOf("locate_offset", Vec3i.ZERO).forGetter(RandomSpreadStructurePlacement::locateOffset)).apply(instance, RandomSpreadStructurePlacement::new);
-    }).flatXmap((placement) -> {
-        return placement.spacing <= placement.separation ? DataResult.error("Spacing has to be larger than separation") : DataResult.success(placement);
-    }, DataResult::success).codec();
+    }).flatXmap((placement) -> placement.spacing <= placement.separation ? DataResult.error("Spacing has to be larger than separation") : DataResult.success(placement), DataResult::success).codec();
+    // Matter end - compile fix
 
     public RandomSpreadStructurePlacement(int spacing, int separation, RandomSpreadType spreadType, int salt) {
         this(spacing, separation, spreadType, salt, Vec3i.ZERO);
@@ -26,8 +29,7 @@ public record RandomSpreadStructurePlacement(int spacing, int separation, Random
         int j = this.separation();
         int k = Math.floorDiv(x, i);
         int l = Math.floorDiv(z, i);
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setLargeFeatureWithSalt(seed, k, l, this.salt());
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(k, l, Globals.Salt.POTENTIONAL_FEATURE, this.salt); // Matter
         int m = i - j;
         int n = this.spreadType().evaluate(worldgenRandom, m);
         int o = this.spreadType().evaluate(worldgenRandom, m);
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/pools/JigsawPlacement.java b/src/main/java/net/minecraft/world/level/levelgen/structure/pools/JigsawPlacement.java
index 67a5481a203bb27e1b4236facda4fb30abc2daf7..0710c071033f61599a7960fa70e14cd40705a762 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/pools/JigsawPlacement.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/pools/JigsawPlacement.java
@@ -23,7 +23,6 @@ import net.minecraft.world.level.block.JigsawBlock;
 import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.levelgen.Heightmap;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
 import net.minecraft.world.level.levelgen.WorldgenRandom;
 import net.minecraft.world.level.levelgen.feature.StructureFeature;
 import net.minecraft.world.level.levelgen.feature.configurations.JigsawConfiguration;
@@ -39,13 +38,16 @@ import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import org.apache.commons.lang3.mutable.MutableObject;
 import org.slf4j.Logger;
+// Matter start
+import su.plo.matter.Globals;
+import su.plo.matter.WorldgenCryptoRandom;
+// Matter end
 
 public class JigsawPlacement {
     static final Logger LOGGER = LogUtils.getLogger();
 
     public static Optional<PieceGenerator<JigsawConfiguration>> addPieces(PieceGeneratorSupplier.Context<JigsawConfiguration> context, JigsawPlacement.PieceFactory pieceFactory, BlockPos pos, boolean bl, boolean bl2) {
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(0L));
-        worldgenRandom.setLargeFeatureSeed(context.seed(), context.chunkPos().x, context.chunkPos().z);
+        WorldgenRandom worldgenRandom = new WorldgenCryptoRandom(context.chunkPos().x, context.chunkPos().z, Globals.Salt.JIGSAW_PLACEMENT, 0); // Matter
         RegistryAccess registryAccess = context.registryAccess();
         JigsawConfiguration jigsawConfiguration = context.config();
         ChunkGenerator chunkGenerator = context.chunkGenerator();
@@ -200,18 +202,16 @@ public class JigsawPlacement {
                                         if (!boundingBox2.isInside(structureBlockInfox.pos.relative(JigsawBlock.getFrontFacing(structureBlockInfox.state)))) {
                                             return 0;
                                         } else {
-                                            ResourceLocation resourceLocation = new ResourceLocation(structureBlockInfox.nbt.getString("pool"));
-                                            Optional<StructureTemplatePool> optional = this.pools.getOptional(resourceLocation);
-                                            Optional<StructureTemplatePool> optional2 = optional.flatMap((pool) -> {
-                                                return this.pools.getOptional(pool.getFallback());
-                                            });
-                                            int i = optional.map((pool) -> {
-                                                return pool.getMaxSize(this.structureManager);
-                                            }).orElse(0);
-                                            int j = optional2.map((pool) -> {
-                                                return pool.getMaxSize(this.structureManager);
-                                            }).orElse(0);
-                                            return Math.max(i, j);
+                                            // Mater start - compile fix
+                                            ResourceLocation poolLocation = new ResourceLocation(structureBlockInfox.nbt.getString("pool"));
+                                            Optional<StructureTemplatePool> pool1 = this.pools.getOptional(poolLocation);
+
+                                            Optional<StructureTemplatePool> pool2 = pool1.flatMap((pool) -> this.pools.getOptional(pool.getFallback()));
+                                            int i1 = pool1.map((pool) -> pool.getMaxSize(this.structureManager)).orElse(0);
+                                            int j1 = pool2.map((pool) -> pool.getMaxSize(this.structureManager)).orElse(0);
+
+                                            return Math.max(i1, j1);
+                                            // Mater end - compile fix
                                         }
                                     }).max().orElse(0);
                                 } else {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index 403aba29347c779da75337531c3723632120e7c9..38f3842cc8109951fe9257619be367f472005a6f 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -206,7 +206,7 @@ public class CraftChunk implements Chunk {
     @Override
     public boolean isSlimeChunk() {
         // 987234911L is deterimined in EntitySlime when seeing if a slime can spawn in a chunk
-        return this.worldServer.paperConfig.allChunksAreSlimeChunks || WorldgenRandom.seedSlimeChunk(this.getX(), this.getZ(), this.getWorld().getSeed(), worldServer.spigotConfig.slimeSeed).nextInt(10) == 0; // Paper
+        return worldServer.getChunk(this.getX(), this.getZ()).isSlimeChunk(); // Paper // Matter
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 6aa8d57f163ae4c65c81bee612e0b977518e97bb..99bbf6c27550d2145c6c553abb52c664eacae961 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -242,6 +242,7 @@ import org.bukkit.util.permissions.DefaultPermissions;
 import org.yaml.snakeyaml.Yaml;
 import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
+import su.plo.matter.Globals; // Matter
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
 
@@ -1204,7 +1205,7 @@ public final class CraftServer implements Server {
         LevelSettings worldSettings;
         // See MinecraftServer.a(String, String, long, WorldType, JsonElement)
         if (worlddata == null) {
-            DedicatedServerProperties.WorldGenProperties properties = new DedicatedServerProperties.WorldGenProperties(Objects.toString(creator.seed()), GsonHelper.parse((creator.generatorSettings().isEmpty()) ? "{}" : creator.generatorSettings()), creator.generateStructures(), creator.type().name().toLowerCase(Locale.ROOT));
+            DedicatedServerProperties.WorldGenProperties properties = new DedicatedServerProperties.WorldGenProperties(Objects.toString(creator.seed()), Globals.INSTANCE.seedToString(Globals.INSTANCE.createRandomWorldSeed()), GsonHelper.parse((creator.generatorSettings().isEmpty()) ? "{}" : creator.generatorSettings()), creator.generateStructures(), creator.type().name().toLowerCase(Locale.ROOT)); // Matter
 
             WorldGenSettings generatorsettings = WorldGenSettings.create(this.console.registryAccess(), properties);
             worldSettings = new LevelSettings(name, GameType.byId(this.getDefaultGameMode().getValue()), hardcore, Difficulty.EASY, false, new GameRules(), console.datapackconfiguration);
diff --git a/src/main/kotlin/su/plo/matter/Globals.kt b/src/main/kotlin/su/plo/matter/Globals.kt
new file mode 100644
index 0000000000000000000000000000000000000000..fafbf00b44921d3bdb1517d3f776a7236381f041
--- /dev/null
+++ b/src/main/kotlin/su/plo/matter/Globals.kt
@@ -0,0 +1,83 @@
+package su.plo.matter
+
+import com.google.common.collect.Iterables
+import net.minecraft.server.level.ServerLevel
+import java.math.BigInteger
+import java.security.SecureRandom
+import java.util.*
+
+
+object Globals {
+	const val WORLD_SEED_LONGS = 16
+	const val WORLD_SEED_BITS = WORLD_SEED_LONGS * 64
+	val worldSeed = LongArray(WORLD_SEED_LONGS)
+	val dimension = ThreadLocal.withInitial { 0 }
+	fun setupGlobals(world: ServerLevel) {
+		val seed: LongArray = TODO() // world.server.worldData.worldGenSettings().featureSeed()
+		System.arraycopy(seed, 0, worldSeed, 0, WORLD_SEED_LONGS)
+		var worldIndex: Int = Iterables.indexOf(world.server.levelKeys()) { it -> it === world.dimension() }
+		if (worldIndex == -1) worldIndex =
+			world.server.levelKeys().size // if we are in world construction it may not have been added to the map yet
+		dimension.set(worldIndex)
+	}
+
+	fun createRandomWorldSeed(): LongArray {
+		val seed = LongArray(WORLD_SEED_LONGS)
+		val rand = SecureRandom()
+		for (i in 0 until WORLD_SEED_LONGS) {
+			seed[i] = rand.nextLong()
+		}
+		return seed
+	}
+
+	fun parseSeed(seedStr: String): Optional<LongArray> {
+		return if (seedStr.isEmpty()) Optional.empty() else try {
+			val seed = LongArray(WORLD_SEED_LONGS)
+			var seedBigInt = BigInteger(seedStr)
+			if (seedBigInt.signum() < 0) {
+				seedBigInt = seedBigInt.and(BigInteger.ONE.shiftLeft(WORLD_SEED_BITS).subtract(BigInteger.ONE))
+			}
+			for (i in 0 until WORLD_SEED_LONGS) {
+				val divRem: Array<BigInteger> = seedBigInt.divideAndRemainder(BigInteger.ONE.shiftLeft(64))
+				seed[i] = TODO() // divRem[1].longValue()
+				seedBigInt = divRem[0]
+			}
+			Optional.of(seed)
+		} catch (ignored: NumberFormatException) {
+			Optional.empty()
+		}
+	}
+
+	fun seedToString(seed: LongArray): String {
+		var seedBigInt: BigInteger = BigInteger.ZERO
+		for (i in WORLD_SEED_LONGS - 1 downTo 0) {
+			var `val`: BigInteger = BigInteger.valueOf(seed[i])
+			if (`val`.signum() < 0) {
+				`val` = `val`.add(BigInteger.ONE.shiftLeft(64))
+			}
+			seedBigInt = seedBigInt.shiftLeft(64).add(`val`)
+		}
+		return seedBigInt.toString()
+	}
+
+	enum class Salt {
+		UNDEFINED,
+		BASTION_FEATURE,
+		WOODLAND_MANSION_FEATURE,
+		MINESHAFT_FEATURE,
+		BURIED_TREASURE_FEATURE,
+		NETHER_FORTRESS_FEATURE,
+		PILLAGER_OUTPOST_FEATURE,
+		GEODE_FEATURE,
+		NETHER_FOSSIL_FEATURE,
+		OCEAN_MONUMENT_FEATURE,
+		RUINED_PORTAL_FEATURE,
+		POTENTIONAL_FEATURE,
+		GENERATE_FEATURE,
+		JIGSAW_PLACEMENT,
+		STRONGHOLDS,
+		POPULATION,
+		DECORATION,
+		SLIME_CHUNK
+	}
+}
\ No newline at end of file
diff --git a/src/main/kotlin/su/plo/matter/Hashing.kt b/src/main/kotlin/su/plo/matter/Hashing.kt
new file mode 100644
index 0000000000000000000000000000000000000000..0f069c26441c1e8ebec78b1105f51ddfb3ffa317
--- /dev/null
+++ b/src/main/kotlin/su/plo/matter/Hashing.kt
@@ -0,0 +1,94 @@
+package su.plo.matter
+
+object Hashing {
+	// https://en.wikipedia.org/wiki/BLAKE_(hash_function)
+	// https://github.com/bcgit/bc-java/blob/master/core/src/main/java/org/bouncycastle/crypto/digests/Blake2bDigest.java
+	private val blake2b_IV = longArrayOf(
+		0x6a09e667f3bcc908L, -0x4498517a7b3558c5L, 0x3c6ef372fe94f82bL,
+		-0x5ab00ac5a0e2c90fL, 0x510e527fade682d1L, -0x64fa9773d4c193e1L,
+		0x1f83d9abfb41bd6bL, 0x5be0cd19137e2179L
+	)
+	private val blake2b_sigma = arrayOf(
+		byteArrayOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15),
+		byteArrayOf(14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3),
+		byteArrayOf(11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4),
+		byteArrayOf(7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8),
+		byteArrayOf(9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13),
+		byteArrayOf(2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9),
+		byteArrayOf(12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11),
+		byteArrayOf(13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10),
+		byteArrayOf(6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5),
+		byteArrayOf(10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0),
+		byteArrayOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15),
+		byteArrayOf(14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3)
+	)
+
+	fun hashWorldSeed(worldSeed: LongArray): LongArray {
+		val result = blake2b_IV.clone()
+		result[0] = result[0] xor 0x01010040L
+		hash(worldSeed, result, LongArray(16), 0, false)
+		return result
+	}
+
+	fun hash(message: LongArray, chainValue: LongArray, internalState: LongArray, messageOffset: Long, isFinal: Boolean) {
+		assert(message.size == 16)
+		assert(chainValue.size == 8)
+		assert(internalState.size == 16)
+		System.arraycopy(chainValue, 0, internalState, 0, chainValue.size)
+		System.arraycopy(blake2b_IV, 0, internalState, chainValue.size, 4)
+		internalState[12] = messageOffset xor blake2b_IV[4]
+		internalState[13] = blake2b_IV[5]
+		if (isFinal) internalState[14] = blake2b_IV[6].inv()
+		internalState[15] = blake2b_IV[7]
+		for (round in 0..11) {
+			g(
+				message[blake2b_sigma[round][0].toInt()],
+				message[blake2b_sigma[round][1].toInt()], 0, 4, 8, 12, internalState
+			)
+			g(
+				message[blake2b_sigma[round][2].toInt()],
+				message[blake2b_sigma[round][3].toInt()], 1, 5, 9, 13, internalState
+			)
+			g(
+				message[blake2b_sigma[round][4].toInt()],
+				message[blake2b_sigma[round][5].toInt()], 2, 6, 10, 14, internalState
+			)
+			g(
+				message[blake2b_sigma[round][6].toInt()],
+				message[blake2b_sigma[round][7].toInt()], 3, 7, 11, 15, internalState
+			)
+			g(
+				message[blake2b_sigma[round][8].toInt()],
+				message[blake2b_sigma[round][9].toInt()], 0, 5, 10, 15, internalState
+			)
+			g(
+				message[blake2b_sigma[round][10].toInt()],
+				message[blake2b_sigma[round][11].toInt()], 1, 6, 11, 12, internalState
+			)
+			g(
+				message[blake2b_sigma[round][12].toInt()],
+				message[blake2b_sigma[round][13].toInt()], 2, 7, 8, 13, internalState
+			)
+			g(
+				message[blake2b_sigma[round][14].toInt()],
+				message[blake2b_sigma[round][15].toInt()], 3, 4, 9, 14, internalState
+			)
+		}
+		for (i in 0..7) {
+			chainValue[i] = chainValue[i] xor (internalState[i] xor internalState[i + 8])
+		}
+	}
+
+	private fun g(m1: Long, m2: Long, posA: Int, posB: Int, posC: Int, posD: Int, internalState: LongArray) {
+		internalState[posA] = internalState[posA] + internalState[posB] + m1
+		internalState[posD] = java.lang.Long.rotateRight(internalState[posD] xor internalState[posA], 32)
+		internalState[posC] = internalState[posC] + internalState[posD]
+		internalState[posB] =
+			java.lang.Long.rotateRight(internalState[posB] xor internalState[posC], 24) // replaces 25 of BLAKE
+		internalState[posA] = internalState[posA] + internalState[posB] + m2
+		internalState[posD] = java.lang.Long.rotateRight(internalState[posD] xor internalState[posA], 16)
+		internalState[posC] = internalState[posC] + internalState[posD]
+		internalState[posB] =
+			java.lang.Long.rotateRight(internalState[posB] xor internalState[posC], 63) // replaces 11 of BLAKE
+	}
+}
\ No newline at end of file
diff --git a/src/main/kotlin/su/plo/matter/WorldgenCryptoRandom.kt b/src/main/kotlin/su/plo/matter/WorldgenCryptoRandom.kt
new file mode 100644
index 0000000000000000000000000000000000000000..28b3b677649909bbc2efc91cf5c637c20ece9886
--- /dev/null
+++ b/src/main/kotlin/su/plo/matter/WorldgenCryptoRandom.kt
@@ -0,0 +1,134 @@
+package su.plo.matter
+
+import net.minecraft.util.Mth
+import net.minecraft.world.level.levelgen.LegacyRandomSource
+import net.minecraft.world.level.levelgen.WorldGenSettings
+import net.minecraft.world.level.levelgen.WorldgenRandom
+import su.plo.matter.Globals.Salt
+import java.util.*
+
+class WorldgenCryptoRandom(x: Int, z: Int, typeSalt: Salt, salt: Long) : WorldgenRandom(LegacyRandomSource(0L)) {
+	private val worldSeed = LongArray(Globals.WORLD_SEED_LONGS)
+	private val randomBits = LongArray(8)
+	private var randomBitIndex = 0
+	private var counter: Long = 0
+	private val message = LongArray(16)
+	private val cachedInternalState = LongArray(16)
+
+	init {
+		setSecureSeed(x, z, typeSalt, salt)
+	}
+
+	fun setSecureSeed(x: Int, z: Int, typeSalt: Salt, salt: Long) {
+		System.arraycopy(Globals.worldSeed, 0, worldSeed, 0, Globals.WORLD_SEED_LONGS)
+		message[0] = x.toLong() shl 32 or (z.toLong() and 0xffffffffL)
+		message[1] = Globals.dimension.get().toLong() shl 32 or (salt and 0xffffffffL)
+		message[2] = typeSalt.ordinal.toLong()
+		counter = 0
+		message[3] = counter
+		randomBitIndex = MAX_RANDOM_BIT_INDEX
+	}
+
+	private val hashedWorldSeed: LongArray
+		get() {
+			if (!Arrays.equals(worldSeed, LAST_SEEN_WORLD_SEED.get())) {
+				HASHED_WORLD_SEED.set(Hashing.hashWorldSeed(worldSeed))
+				System.arraycopy(worldSeed, 0, LAST_SEEN_WORLD_SEED.get(), 0, Globals.WORLD_SEED_LONGS)
+			}
+			return HASHED_WORLD_SEED.get()
+		}
+
+	private fun moreRandomBits() {
+		message[3] = counter++
+		System.arraycopy(hashedWorldSeed, 0, randomBits, 0, 8)
+		Hashing.hash(message, randomBits, cachedInternalState, 64, true)
+	}
+
+	private fun getBits(count: Int): Long {
+		if (randomBitIndex >= MAX_RANDOM_BIT_INDEX) {
+			moreRandomBits()
+			randomBitIndex -= MAX_RANDOM_BIT_INDEX
+		}
+		var alignment = randomBitIndex and 63
+		return if (randomBitIndex ushr 6 == randomBitIndex + count ushr 6) {
+			val result = randomBits[randomBitIndex ushr 6] ushr alignment and (1L shl count) - 1
+			randomBitIndex += count
+			result
+		} else {
+			var result = randomBits[randomBitIndex ushr 6] ushr alignment and (1L shl 64 - alignment) - 1
+			randomBitIndex += count
+			if (randomBitIndex >= MAX_RANDOM_BIT_INDEX) {
+				moreRandomBits()
+				randomBitIndex -= MAX_RANDOM_BIT_INDEX
+			}
+			alignment = randomBitIndex and 63
+			result = result shl alignment
+			result = result or (randomBits[randomBitIndex ushr 6] ushr 64 - alignment and (1L shl alignment) - 1)
+			result
+		}
+	}
+
+	override fun next(bits: Int): Int {
+		return getBits(bits).toInt()
+	}
+
+	override fun consumeCount(count: Int) {
+		randomBitIndex += count
+		if (randomBitIndex >= MAX_RANDOM_BIT_INDEX * 2) {
+			randomBitIndex -= MAX_RANDOM_BIT_INDEX
+			counter += (randomBitIndex ushr LOG2_MAX_RANDOM_BIT_INDEX).toLong()
+			randomBitIndex = randomBitIndex and MAX_RANDOM_BIT_INDEX - 1
+			randomBitIndex += MAX_RANDOM_BIT_INDEX
+		}
+	}
+
+	override fun nextInt(bound: Int): Int {
+		val bits = Mth.ceillog2(bound)
+		var result: Int
+		do {
+			result = getBits(bits).toInt()
+		} while (result >= bound)
+		return result
+	}
+
+	override fun nextLong(): Long {
+		return getBits(64)
+	}
+
+	override fun nextDouble(): Double {
+		return (getBits(53) * 0x1).toDouble() //! Need fix
+	}
+
+	override fun setDecorationSeed(worldSeed: Long, blockX: Int, blockZ: Int): Long {
+		setSecureSeed(blockX, blockZ, Salt.POPULATION, 0)
+		return blockX.toLong() shl 32 or (blockZ.toLong() and 0xffffffffL)
+	}
+
+	override fun setFeatureSeed(populationSeed: Long, index: Int, step: Int) {
+		setSecureSeed((populationSeed shr 32).toInt(), populationSeed.toInt(), Salt.DECORATION, index + 10000L * step)
+	}
+
+	override fun setLargeFeatureSeed(worldSeed: Long, chunkX: Int, chunkZ: Int) {
+		super.setLargeFeatureSeed(worldSeed, chunkX, chunkZ)
+	}
+
+	override fun setLargeFeatureWithSalt(worldSeed: Long, regionX: Int, regionZ: Int, salt: Int) {
+		super.setLargeFeatureWithSalt(worldSeed, regionX, regionZ, salt)
+	}
+
+	companion object {
+		// hash the world seed to guard against badly chosen world seeds
+		private val HASHED_ZERO_SEED: LongArray = Hashing.hashWorldSeed(LongArray(Globals.WORLD_SEED_LONGS))
+		private val LAST_SEEN_WORLD_SEED = ThreadLocal.withInitial {
+			LongArray(
+				Globals.WORLD_SEED_LONGS
+			)
+		}
+		private val HASHED_WORLD_SEED = ThreadLocal.withInitial { HASHED_ZERO_SEED }
+		private const val MAX_RANDOM_BIT_INDEX = 64 * 8
+		private const val LOG2_MAX_RANDOM_BIT_INDEX = 9
+		fun seedSlimeChunk(chunkX: Int, chunkZ: Int): Random {
+			return WorldgenCryptoRandom(chunkX, chunkZ, Salt.SLIME_CHUNK, 0)
+		}
+	}
+}
\ No newline at end of file
